#include <iostream>
#include <queue>
using namespace std;

/************************************************************
广度优先搜索算法的基本思想：
1、对于初始状态入队，设置初始状态为已访问
2、如果队列不为空时，出队队头元素，否则跳到第5步
3、检查出队的元素是否为最终解，如果是则跳到第5步。
4、对于出队的元素，检查所有相邻状态，如果有效并且未访问，则将
   所有有效的相邻状态进行入队，并且设置这些状态为已访问，然后
   跳到第2步重复执行
5、检查最后出队的元素是否为最终解，如果是输出结果，否则说明无解

广度优先搜索是借助于队列这种数据结构进行搜索的，队列的特点是先
进先出（FIFO），通过包含queue这个队列模板头文件，就可以利用c++
的队列模板定义自己的队列了，队列的操作非常简单，主要有以下几个：
q.push() 入队操作
q.front() 取队头元素
q.pop() 队头元素出队
q.size() 获取队列的元素个数
q.empty() 判断队列是否为空，为空返回true，不为空返回false

广度优先搜索算法的关键是要搞清楚求解过程中每一步的相邻状态有哪些，
每个状态需要记录什么信息，在搜索过程中如何标记这些状态为已访问。

在本题中，相邻状态为当前所在楼层通过按向上或向下按钮所能到达的楼
层，每个状态要记录的信息包括楼层编号和按按钮的次数。
*************************************************************/

//定义队列元素的类型，QElement为结构类型，使用typedef可以定义一个新的类型名称，在程序中QElement就像int、float一样，作为一个数据类型的名称使用
typedef struct {
    int floor;  //当前所处的楼层编号
    int pushcount;  //到达该楼层所经历的步数（按按钮次数）
} QElement;

queue<QElement> q; //定义元素类型为QElement的队列q

int n,a,b;
int s[1000];     //数组s记录每个楼层按按钮后能上下的楼层数
int t[1000]={0}; //数组t记录各个楼层是否已经到达过（已访问过）

int main()
{
    QElement e1,e2;
    int i;

    cin >> n >> a >> b;
    for (i=1; i<=n; i++) cin >> s[i];

    e1.floor=a;
    e1.pushcount=0;
    q.push(e1);  //初始状态入队：当前楼层为a，按按钮次数为0
    t[a]=1;  //记录当前楼层已访问过
    while (!q.empty())  //当队列不为空时，继续宽度优先搜索
    {
        e2=q.front();   //获取队头元素
        q.pop();  //队头元素出队（注意：c++的队列模板类中，获取队头元素并不会将该元素从队列中删除，需要使用pop函数删除该元素）
        if (e2.floor==b) break;  //检查当前状态的楼层编号是否为b，是则说明已经找到最终解，跳出循环
        i=e2.floor+s[e2.floor];  //按向上按钮后能够到达的楼层
        if (i<=n && t[i]==0)  //如果按向上按钮能到达的楼层有效并且未访问过该楼层
        {
            e1.floor=i;
            e1.pushcount=e2.pushcount+1;
            q.push(e1);
            t[i]=1;  //设该楼层为已访问过
        }
        i=e2.floor-s[e2.floor];  //按向下按钮后能够到达的楼层
        if (i>=1 && t[i]==0)  //如果按向下按钮能到达的楼层有效并且未访问过该楼层
        {
            e1.floor=i;
            e1.pushcount=e2.pushcount+1;
            q.push(e1);
            t[i]=1;  //设该楼层为已访问过
        }
    }

    //如果当前楼层为b，输出按按钮次数，否则无解（输出-1）
    if (e2.floor==b) cout << e2.pushcount;
    else cout << -1;
}